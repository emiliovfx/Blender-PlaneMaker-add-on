# File: cis_pm_addon/pm_adapter.py
# Blender 4.5+ — Virtual OBJ exporter used as a bridge for cis_*2pm modules.
# Emits an OBJ-like dataset from the selected collection (recursive, visible-only),
# applies modifiers + world transforms, remaps axes to (-Z forward, Y up),
# preserves polygon faces (no triangulation), and dumps to 'virtual_obj_dump.txt'.

from __future__ import annotations
import os
import shutil
from typing import Iterable, List, Optional, Tuple

try:
    import bpy
except ImportError:  # allow static analysis outside Blender
    bpy = None


# ----------------------------
# Paths
# ----------------------------
def _addon_root() -> str:
    return os.path.dirname(os.path.abspath(__file__))

def _vmesh_dir() -> str:
    d = os.path.join(_addon_root(), "vmesh")
    os.makedirs(d, exist_ok=True)
    return d

def default_dump_path() -> str:
    return os.path.join(_vmesh_dir(), "virtual_obj_dump.txt")



# ----------------------------
# Collection walk (visible-only)
# ----------------------------
def _iter_visible_mesh_objects_recursive(collection: "bpy.types.Collection") -> Iterable["bpy.types.Object"]:
    """
    Yield mesh objects that are visible in the viewport within `collection` and subcollections.
    WHY: Only visible elements are part of the flight model dataset.
    """
    yielded = set()

    for obj in collection.objects:
        if obj.type == "MESH" and obj.visible_get():
            if obj.name_full not in yielded:
                yielded.add(obj.name_full)
                yield obj

    for child in collection.children_recursive:
        for obj in child.objects:
            if obj.type == "MESH" and obj.visible_get():
                if obj.name_full not in yielded:
                    yielded.add(obj.name_full)
                    yield obj


# ----------------------------
# Axis remap
# ----------------------------
def _axis_remap_blender_to_target(xb: float, yb: float, zb: float) -> Tuple[float, float, float]:
    """
    Blender: -Y forward, Z up  → Target: -Z forward, Y up
    Match reference orientation:
      Xt = Xb
      Yt = Zb
      Zt = -Yb
    """
    return xb, zb, -yb


# ----------------------------
# Mesh evaluation
# ----------------------------
def _eval_mesh_world(obj: "bpy.types.Object", depsgraph: "bpy.types.Depsgraph") -> "bpy.types.Mesh":
    """
    Apply modifiers and bake world transform into a temporary Mesh.
    WHY: Downstream expects world-space geometry consistent with OBJ output.
    """
    ob_eval = obj.evaluated_get(depsgraph)
    mesh = ob_eval.to_mesh(preserve_all_data_layers=False, depsgraph=depsgraph)
    mesh.transform(obj.matrix_world)
    return mesh


# ----------------------------
# Virtual OBJ builder
# ----------------------------
def build_virtual_obj_lines(
    context: "bpy.types.Context",
    selected_collection: "bpy.types.Collection",
    *,
    sort_by_name: bool = False,  # preserve collection traversal order by default
) -> List[str]:
    """
    Build an in-memory OBJ dataset (list of text lines) with this structure:
      o <ObjectName>
      v x y z
      ...
      f i j k ...
    for each visible mesh (recursive) in `selected_collection`, with:
      - Modifiers applied, world transform baked.
      - Axis remap: (-Y fwd, Z up) → (-Z fwd, Y up) via Xt=Xb, Yt=Zb, Zt=-Yb.
      - Polygon faces preserved (no triangulation).
      - Global 1-based vertex indexing across objects.
    """
    if bpy is None:
        raise RuntimeError("pm_adapter must be executed inside Blender.")

    dg = context.evaluated_depsgraph_get()
    objs = list(_iter_visible_mesh_objects_recursive(selected_collection))
    if sort_by_name:
        objs.sort(key=lambda o: o.name)

    lines: List[str] = []
    lines.append("# virtual OBJ generated by pm_adapter (Blender 4.5+)\n")

    global_vertex_count = 0  # 0-based counter used to compute OBJ 1-based indices

    for obj in objs:
        mesh = _eval_mesh_world(obj, dg)
        try:
            # Object header first (so dataset matches reference layout)
            lines.append(f"o {obj.name}\n")

            # Emit vertices (axis remapped)
            start_index = global_vertex_count
            for v in mesh.vertices:
                xt, yt, zt = _axis_remap_blender_to_target(v.co.x, v.co.y, v.co.z)
                lines.append(f"v {xt:.6f} {yt:.6f} {zt:.6f}\n")
            global_vertex_count += len(mesh.vertices)

            # Emit polygon faces (variable-length), 1-based global indices
            for poly in mesh.polygons:
                idxs = [start_index + vi + 1 for vi in poly.vertices]
                lines.append("f " + " ".join(str(i) for i in idxs) + "\n")

        finally:
            # Release evaluated mesh
            obj.to_mesh_clear()

    return lines


# ----------------------------
# Pipeline entry — bodies (stub stage)
# ----------------------------
def run_bodies_from_collection(
    *,
    collection: "bpy.types.Collection",
    acf_in_path: str,
    acf_out_path: str,
    template_path: str,   # retained for signature compatibility with caller
    dump_path: Optional[str] = None,
    logger=lambda m: print(m),
) -> None:
    """
    CURRENT STAGE: generate & dump virtual OBJ ONLY (for verification), do not call cis_bodies2pm/cis_wings2pm yet.
    - Create backup: <acf_in> -> <*_bak.acf> in the same directory.
    - Write an unchanged copy of acf_in_path to acf_out_path (placeholder).
    - Dump virtual OBJ to 'virtual_obj_dump.txt' (or custom dump_path) for comparison.
    """
    if bpy is None:
        raise RuntimeError("pm_adapter must be executed inside Blender.")

    if not isinstance(collection, bpy.types.Collection):
        raise ValueError("Invalid collection provided.")

    if not acf_in_path or not os.path.isfile(acf_in_path):
        raise FileNotFoundError(f"ACF input not found: {acf_in_path}")

    # Build virtual OBJ lines
    ctx = bpy.context
    lines = build_virtual_obj_lines(ctx, collection)

    # Dump to file for verification
    dump_path = dump_path or default_dump_path()
    try:
        with open(dump_path, "w", encoding="utf-8") as f:
            f.writelines(lines)
        logger(f"[CIS_PM] Virtual OBJ dumped: {dump_path}")
        logger(f"[CIS_PM] Dump size: {len(lines)} line(s)")
    except Exception as e:
        logger(f"[CIS_PM] WARNING: failed to write virtual OBJ dump: {e}")

    # Backup original ACF as *_bak.acf (same directory)
    base, ext = os.path.splitext(acf_in_path)
    bak_path = f"{base}_bak{ext}"
    try:
        shutil.copy2(acf_in_path, bak_path)
        logger(f"[CIS_PM] Backup created: {bak_path}")
    except Exception as e:
        logger(f"[CIS_PM] WARNING: failed to create backup: {e}")

    # Placeholder: copy input ACF to output path (keeps operator flow intact for this verification stage)
    try:
        os.makedirs(os.path.dirname(acf_out_path), exist_ok=True)
        shutil.copy2(acf_in_path, acf_out_path)
        logger(f"[CIS_PM] Placeholder ACF written (unchanged copy): {acf_out_path}")
    except Exception as e:
        logger(f"[CIS_PM] ERROR: failed to write placeholder ACF: {e}")
        raise
